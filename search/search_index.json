{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"b-captain-hook Captain hook is a Python WSGI application that handles webhooks from gitea and github. Forked from carlos-jenkins/python-github-webhooks . To install captain hook: git clone https://git.charlesreid1.com/bots/b-captain-hook.git cd b-captain-hook pip install -r requirements.txt cp config.example.json config.json # edit config.json Run it standalone: python captain_hook.py Run it with docker: docker-compose build docker-compose up -d docker-compose down What is Captain Hook? Captain Hook is a flask webhook server that runs via docker. See What is Captain Hook? for an explanation. Configuring Captain Hook Captain Hook requires a config file. See config.example.json in this directory, and the Captain Hook Config page for more info. Starting Captain Hook See Starting Captain Hook for how to set up the various startup services and docker pods that are required to run Captain Hook. Adding Hooks Captain Hook accepts incoming webhooks and checks for scripts in hooks/ that match the action performed on the given repository. A webhook script is anything that is executable. To add a new script to be triggered on a particular webhook, put it in the hooks/ directory and follow the naming convention: b-captain-hook/ hooks/{event}-{name}-{branch} hooks/{event}-{name} hooks/{event} hooks/all For example, suppose I performed a push action to a repository named happy-giraffe , and I was pushing commits to the gh-pages branch. The webhook sent to Captain Hook would contain this information, and Captain Hook would look for any webhooks with the following names, and run them if present: b-captain-hook/ hooks/push-happy-giraffe-gh-pages hooks/push-happy-giraffe hooks/push hooks/all The application passes the path to a JSON file, while holding the payload for the request as the first argument. The application will pass in two pieces of information: Path to JSON file holding payload - the first part of the request is a JSON file that holds the payload for the request. The other piece of information passed is the name of the action (e.g., push ) The application will pass to the hooks the path to a JSON file holding the payload for the request as first argument. The event type will be passed as second argument. For example: hooks/push-happy-giraffe-master /tmp/sXFHji push Hooks can be written in any scripting language as long as the file is executable and has a shebang. A simple example in Python could be: #!/usr/bin/env python # Python Example for Python GitHub Webhooks # File: push-happy-giraffe-master import sys import json with open(sys.argv[1], 'r') as jsf: payload = json.loads(jsf.read()) ### Do something with the payload name = payload['repository']['name'] outfile = '/tmp/hook-{}.log'.format(name) with open(outfile, 'w') as f: f.write(json.dumps(payload)) Not all events have an associated branch, so a branch-specific hook cannot fire for such events. For events that contain a pull_request object, the base branch (target for the pull request) is used, not the head branch. The payload structure depends on the event type. Please review: https://developer.github.com/v3/activity/events/types/ Docker Deployment Dockerfile defines the image, but use the docker-compose.yml file instead. To build, start, and stop: docker-compose build --no-cache docker-compose up docker-compose down Base Docker Image Captain Hook uses the python3-alpine-flask container, which is a very lightweight container with python 3 available and with flask installed. See nikos/python3-alpine-flask-docker on Github. Ports Captain Hook binds to external port 5000 on whatever host it runs on. Implementing a secret key is critical to keep captain hook from deploying webhook requests from random strangers. Recommendations: You can implement validation of the IP address sending the webhook, but more important than validating the incoming IP address (which can always be spoofed) is to validate the secret. Volumes THe docker container mounts the hooks/ directory in this repository to /app/hooks in the container. ./hooks:/app/hooks NOTE: These scripts must be made executable with chmod +x or the webhook server will not do anything and be totally silent. The docker container will also mount /www/ into the container, so all the static web content on the host (blackbeard) is available to the webhooks to perform updates and etc. /www is mounted to the same place on the host and in the container, as indicated by this bind mount lin from the docker-compose file: /www:/www Testing To test Captain Hook, install a webhook in a given repository and use the server running Captain Hook as the endpoint. Set up the secret. You should be able to trigger a webhook test from the repository's webhooks control panel. This should trigger Captain Hook, and if you've added a script for the corresponding repository, it should be triggered by the test. Keep in mind that Gitea/Github will only fire triggers on the master branch of a repository, so you can't test arbitrary branches using this method. Debugging To get into test/debug mode: Set up a \"dummy\" hook (the Python hook shown above) that will just log the webhook to a log file in /tmp Run the server in one window In a second window, open a shell in the container and monitor /tmp/*.log In a third window, open a shell in the container and monitor /www/* To open a shell inside the container, run this command from the host machine: docker exec -it <name-of-container> /bin/sh Remember that when you are inside this container, you will only have /bin/sh available - no bash . To check logs of this container, run this from the host machine: docker logs -f <container-name> You can also run the container without sending it to the background, docker-compose up and this will show exceptions on the screen (but it won't show anything else useful...) Licenses Original license (Carlos Jenkins) and forked license (Charles Reid) given in license.md Credits This project is just the reinterpretation and merge of two approaches: github-webhook-wrapper flask-github-webhook It is implemented with the help of python 3 alpine: nikos/python3-alpine-flask-docker","title":"Home"},{"location":"#b-captain-hook","text":"Captain hook is a Python WSGI application that handles webhooks from gitea and github. Forked from carlos-jenkins/python-github-webhooks . To install captain hook: git clone https://git.charlesreid1.com/bots/b-captain-hook.git cd b-captain-hook pip install -r requirements.txt cp config.example.json config.json # edit config.json Run it standalone: python captain_hook.py Run it with docker: docker-compose build docker-compose up -d docker-compose down","title":"b-captain-hook"},{"location":"#what-is-captain-hook","text":"Captain Hook is a flask webhook server that runs via docker. See What is Captain Hook? for an explanation.","title":"What is Captain Hook?"},{"location":"#configuring-captain-hook","text":"Captain Hook requires a config file. See config.example.json in this directory, and the Captain Hook Config page for more info.","title":"Configuring Captain Hook"},{"location":"#starting-captain-hook","text":"See Starting Captain Hook for how to set up the various startup services and docker pods that are required to run Captain Hook.","title":"Starting Captain Hook"},{"location":"#adding-hooks","text":"Captain Hook accepts incoming webhooks and checks for scripts in hooks/ that match the action performed on the given repository. A webhook script is anything that is executable. To add a new script to be triggered on a particular webhook, put it in the hooks/ directory and follow the naming convention: b-captain-hook/ hooks/{event}-{name}-{branch} hooks/{event}-{name} hooks/{event} hooks/all For example, suppose I performed a push action to a repository named happy-giraffe , and I was pushing commits to the gh-pages branch. The webhook sent to Captain Hook would contain this information, and Captain Hook would look for any webhooks with the following names, and run them if present: b-captain-hook/ hooks/push-happy-giraffe-gh-pages hooks/push-happy-giraffe hooks/push hooks/all The application passes the path to a JSON file, while holding the payload for the request as the first argument. The application will pass in two pieces of information: Path to JSON file holding payload - the first part of the request is a JSON file that holds the payload for the request. The other piece of information passed is the name of the action (e.g., push ) The application will pass to the hooks the path to a JSON file holding the payload for the request as first argument. The event type will be passed as second argument. For example: hooks/push-happy-giraffe-master /tmp/sXFHji push Hooks can be written in any scripting language as long as the file is executable and has a shebang. A simple example in Python could be: #!/usr/bin/env python # Python Example for Python GitHub Webhooks # File: push-happy-giraffe-master import sys import json with open(sys.argv[1], 'r') as jsf: payload = json.loads(jsf.read()) ### Do something with the payload name = payload['repository']['name'] outfile = '/tmp/hook-{}.log'.format(name) with open(outfile, 'w') as f: f.write(json.dumps(payload)) Not all events have an associated branch, so a branch-specific hook cannot fire for such events. For events that contain a pull_request object, the base branch (target for the pull request) is used, not the head branch. The payload structure depends on the event type. Please review: https://developer.github.com/v3/activity/events/types/","title":"Adding Hooks"},{"location":"#docker-deployment","text":"Dockerfile defines the image, but use the docker-compose.yml file instead. To build, start, and stop: docker-compose build --no-cache docker-compose up docker-compose down","title":"Docker Deployment"},{"location":"#base-docker-image","text":"Captain Hook uses the python3-alpine-flask container, which is a very lightweight container with python 3 available and with flask installed. See nikos/python3-alpine-flask-docker on Github.","title":"Base Docker Image"},{"location":"#ports","text":"Captain Hook binds to external port 5000 on whatever host it runs on. Implementing a secret key is critical to keep captain hook from deploying webhook requests from random strangers. Recommendations: You can implement validation of the IP address sending the webhook, but more important than validating the incoming IP address (which can always be spoofed) is to validate the secret.","title":"Ports"},{"location":"#volumes","text":"THe docker container mounts the hooks/ directory in this repository to /app/hooks in the container. ./hooks:/app/hooks NOTE: These scripts must be made executable with chmod +x or the webhook server will not do anything and be totally silent. The docker container will also mount /www/ into the container, so all the static web content on the host (blackbeard) is available to the webhooks to perform updates and etc. /www is mounted to the same place on the host and in the container, as indicated by this bind mount lin from the docker-compose file: /www:/www","title":"Volumes"},{"location":"#testing","text":"To test Captain Hook, install a webhook in a given repository and use the server running Captain Hook as the endpoint. Set up the secret. You should be able to trigger a webhook test from the repository's webhooks control panel. This should trigger Captain Hook, and if you've added a script for the corresponding repository, it should be triggered by the test. Keep in mind that Gitea/Github will only fire triggers on the master branch of a repository, so you can't test arbitrary branches using this method.","title":"Testing"},{"location":"#debugging","text":"To get into test/debug mode: Set up a \"dummy\" hook (the Python hook shown above) that will just log the webhook to a log file in /tmp Run the server in one window In a second window, open a shell in the container and monitor /tmp/*.log In a third window, open a shell in the container and monitor /www/* To open a shell inside the container, run this command from the host machine: docker exec -it <name-of-container> /bin/sh Remember that when you are inside this container, you will only have /bin/sh available - no bash . To check logs of this container, run this from the host machine: docker logs -f <container-name> You can also run the container without sending it to the background, docker-compose up and this will show exceptions on the screen (but it won't show anything else useful...)","title":"Debugging"},{"location":"#licenses","text":"Original license (Carlos Jenkins) and forked license (Charles Reid) given in license.md","title":"Licenses"},{"location":"#credits","text":"This project is just the reinterpretation and merge of two approaches: github-webhook-wrapper flask-github-webhook It is implemented with the help of python 3 alpine: nikos/python3-alpine-flask-docker","title":"Credits"},{"location":"config/","text":"Captain Hook Config Config file config.json should contain: { \"whitelist_ips\": true, \"enforce_secret\": \"SOMELONGSECRETSTRINGTHATYOUPASTEINTOGITHUBORGITEAWEBINTERFACE\", \"return_scripts_info\": true, \"hooks_path\": \"/hooks\" } enforce_secret - require X-Hub-Signature in header. Not enforced if empty. return_scripts_info - return a JSON with the stdout , stderr and exit code for each executed hook using the hook name as key. If this option is set you will be able to see the result of your hooks from within your GitHub hooks configuration page (see \"Recent Deliveries\"). hooks_path - Configures a path to import the hooks. Example: /app/hooks","title":"Configuring Captain Hook"},{"location":"config/#captain-hook-config","text":"Config file config.json should contain: { \"whitelist_ips\": true, \"enforce_secret\": \"SOMELONGSECRETSTRINGTHATYOUPASTEINTOGITHUBORGITEAWEBINTERFACE\", \"return_scripts_info\": true, \"hooks_path\": \"/hooks\" } enforce_secret - require X-Hub-Signature in header. Not enforced if empty. return_scripts_info - return a JSON with the stdout , stderr and exit code for each executed hook using the hook name as key. If this option is set you will be able to see the result of your hooks from within your GitHub hooks configuration page (see \"Recent Deliveries\"). hooks_path - Configures a path to import the hooks. Example: /app/hooks","title":"Captain Hook Config"},{"location":"license/","text":"License for Fork Copyright (c) 2018 Charles Reid Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. License from Forked Repo Copyright (C) 2014-2015 Carlos Jenkins <carlos@jenkins.co.cr> Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Captain Hook License"},{"location":"license/#license-for-fork","text":"Copyright (c) 2018 Charles Reid Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License for Fork"},{"location":"license/#license-from-forked-repo","text":"Copyright (C) 2014-2015 Carlos Jenkins <carlos@jenkins.co.cr> Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License from Forked Repo"},{"location":"starting/","text":"Starting Captain Hook NOTE: Captain Hook can be run by itself, but is designed to run as part of the pod-webhooks docker pod. Instructions below are not guaranteed to work outside of the docker pod. Captain Hook Docker \"Pod\" To run Captain Hook, we utilize a Docker compose file to run the container that runs Captain Hook and mounts the correct directories in the correct locations. See docker-compose.yml in the Captain Hook repository. This is a one-container pod. To start/stop/build it, docker-compose up -d # start in background docker-compose down docker-compose build To rebuild from scratch, docker-compose build --no-cache Startup Service: Captain Hook Docker Pod In order to start the Captain Hook docker pod automatically at startup, and automatically restart the pod if it crashes or is stopped, we install a startup service called dockerpod-captainhook : [Unit] Description=captain hook webhook server docker pod Requires=docker.service After=docker.service [Service] Restart=always ExecStart=/usr/local/bin/docker-compose -f /home/charles/codes/bots/b-captain-hook/docker-compose.yml up ExecStop=/usr/local/bin/docker-compose -f /home/charles/codes/bots/b-captain-hook/docker-compose.yml down [Install] WantedBy=default.target This startup service runs docker-compose with the -f flag to specify an absolute path to the Captain Hook docker-compose.yml file. Startup Service: Captain Hook Canary Captain Hook listens for incoming web hooks and (optionally) runs a script in the hooks/ folder, based on the type of action, the name of the repository, and the name of the branch. However, there is one tricky task: Captain Hook must be able update itself when there are changes pushed to the Captain Hook repository. To resolve this, we run a \"canary\" startup service for Captain Hook. This canary startup service runs a shell script that checks (every 10 seconds) for the presence of a file at /tmp/triggers/ . If this file is present, the host copy of Captain Hook is updated, the Captain Hook docker pod is restarted, and the trigger file is removed. This allows webhooks received by Captain Hook (which occur inside of a Docker container) to trigger an event on the host machine by bind-mounting /tmp/triggers/ and adding a file to this directory. captain-hook-canary.service : [Unit] Description=captain hook canary script Requires=dockerpod-captainhook.service After=dockerpod-captainhook.service [Service] Restart=always ExecStart=/home/charles/blackbeard_scripts/captain_hook_canary.sh ExecStop=/usr/bin/pgrep -f captain_hook_canary | /usr/bin/xargs /bin/kill [Install] WantedBy=default.target Also see captain-hook-canary.service in https://git.charlesreid1.com/dotfiles/debian . This script calls the Captain Hook canary script, which is given below: captain_hook_canary.sh : #!/bin/bash : ' Captain Hook Canary Script Note: this needs an associated systemd service. See the services directory of the dotfiles repo. (snip comments) ' while true do # bootstrap-pull captain hook if [ -f \"/tmp/triggers/push-b-captain-hook-master\" ]; then echo \"CAPTAIN HOOK'S CANARY:\" echo \"Running trigger to update Captain Hook on the host machine (user charles)\" sudo -H -u charles python /home/charles/blackbeard_scripts/captain_hook_pull_host.py echo \"All done.\" rm -f \"/tmp/triggers/push-b-captain-hook-master\" fi sleep 10; done Also see captain_hook_canary.sh in the dotfiles/blackbeard_scripts folder of https://git.charlesreid1.com/dotfiles/debian . When this canary script for Captain Hook is triggered by the presence of a file at /tmp/triggers/push-b-captain-hook-master (which is mounted inside the container at th same location as outside the container), it will run a script to pull Captain Hook: captain_hook_pull_host.py : #!/usr/bin/env python3 import subprocess import os import time \"\"\" Captain Hook: Pull Captain Hook on the Host This script is called by the host machine (blackbeard) running the Captain Hook container. This is triggered by push actions to the master branch of b-captain-hook. The action is to update (git pull) the copy of captain hook running on the host, and restart the container pod. \"\"\" work_dir = os.path.join('/home','charles','codes','bots','b-captain-hook') # Step 1: # Update Captain Hook pull_cmd = ['git','pull','origin','master'] subprocess.call(pull_cmd, cwd=work_dir) time.sleep(5) # Step 2: # Restart Captain Hook pod pod_restart = ['docker-compose','restart'] subprocess.call(pod_restart, cwd=work_dir)","title":"Getting Started"},{"location":"starting/#starting-captain-hook","text":"NOTE: Captain Hook can be run by itself, but is designed to run as part of the pod-webhooks docker pod. Instructions below are not guaranteed to work outside of the docker pod.","title":"Starting Captain Hook"},{"location":"starting/#captain-hook-docker-pod","text":"To run Captain Hook, we utilize a Docker compose file to run the container that runs Captain Hook and mounts the correct directories in the correct locations. See docker-compose.yml in the Captain Hook repository. This is a one-container pod. To start/stop/build it, docker-compose up -d # start in background docker-compose down docker-compose build To rebuild from scratch, docker-compose build --no-cache","title":"Captain Hook Docker \"Pod\""},{"location":"starting/#startup-service-captain-hook-docker-pod","text":"In order to start the Captain Hook docker pod automatically at startup, and automatically restart the pod if it crashes or is stopped, we install a startup service called dockerpod-captainhook : [Unit] Description=captain hook webhook server docker pod Requires=docker.service After=docker.service [Service] Restart=always ExecStart=/usr/local/bin/docker-compose -f /home/charles/codes/bots/b-captain-hook/docker-compose.yml up ExecStop=/usr/local/bin/docker-compose -f /home/charles/codes/bots/b-captain-hook/docker-compose.yml down [Install] WantedBy=default.target This startup service runs docker-compose with the -f flag to specify an absolute path to the Captain Hook docker-compose.yml file.","title":"Startup Service: Captain Hook Docker Pod"},{"location":"starting/#startup-service-captain-hook-canary","text":"Captain Hook listens for incoming web hooks and (optionally) runs a script in the hooks/ folder, based on the type of action, the name of the repository, and the name of the branch. However, there is one tricky task: Captain Hook must be able update itself when there are changes pushed to the Captain Hook repository. To resolve this, we run a \"canary\" startup service for Captain Hook. This canary startup service runs a shell script that checks (every 10 seconds) for the presence of a file at /tmp/triggers/ . If this file is present, the host copy of Captain Hook is updated, the Captain Hook docker pod is restarted, and the trigger file is removed. This allows webhooks received by Captain Hook (which occur inside of a Docker container) to trigger an event on the host machine by bind-mounting /tmp/triggers/ and adding a file to this directory. captain-hook-canary.service : [Unit] Description=captain hook canary script Requires=dockerpod-captainhook.service After=dockerpod-captainhook.service [Service] Restart=always ExecStart=/home/charles/blackbeard_scripts/captain_hook_canary.sh ExecStop=/usr/bin/pgrep -f captain_hook_canary | /usr/bin/xargs /bin/kill [Install] WantedBy=default.target Also see captain-hook-canary.service in https://git.charlesreid1.com/dotfiles/debian . This script calls the Captain Hook canary script, which is given below: captain_hook_canary.sh : #!/bin/bash : ' Captain Hook Canary Script Note: this needs an associated systemd service. See the services directory of the dotfiles repo. (snip comments) ' while true do # bootstrap-pull captain hook if [ -f \"/tmp/triggers/push-b-captain-hook-master\" ]; then echo \"CAPTAIN HOOK'S CANARY:\" echo \"Running trigger to update Captain Hook on the host machine (user charles)\" sudo -H -u charles python /home/charles/blackbeard_scripts/captain_hook_pull_host.py echo \"All done.\" rm -f \"/tmp/triggers/push-b-captain-hook-master\" fi sleep 10; done Also see captain_hook_canary.sh in the dotfiles/blackbeard_scripts folder of https://git.charlesreid1.com/dotfiles/debian . When this canary script for Captain Hook is triggered by the presence of a file at /tmp/triggers/push-b-captain-hook-master (which is mounted inside the container at th same location as outside the container), it will run a script to pull Captain Hook: captain_hook_pull_host.py : #!/usr/bin/env python3 import subprocess import os import time \"\"\" Captain Hook: Pull Captain Hook on the Host This script is called by the host machine (blackbeard) running the Captain Hook container. This is triggered by push actions to the master branch of b-captain-hook. The action is to update (git pull) the copy of captain hook running on the host, and restart the container pod. \"\"\" work_dir = os.path.join('/home','charles','codes','bots','b-captain-hook') # Step 1: # Update Captain Hook pull_cmd = ['git','pull','origin','master'] subprocess.call(pull_cmd, cwd=work_dir) time.sleep(5) # Step 2: # Restart Captain Hook pod pod_restart = ['docker-compose','restart'] subprocess.call(pod_restart, cwd=work_dir)","title":"Startup Service: Captain Hook Canary"},{"location":"what/","text":"What is Captain Hook? The Short Version Captain Hook enables a Github Pages-like push-to-deploy setup for git.charlesreid1.com. Installing webhooks into repositories on https://git.charlesreid1.com allows the gh-pages branch of the given repository to be hosted live on https://pages.charlesreid1.com . The Long Version Captain Hook is a Python Flask server that listens for incoming web hooks from Gitea (or Github), and uses those web hooks to deply pages to https://pages.charlesreid1.com . Captain Hook works by providing a webhook endpoint (rounting provided by nginx container in pod-charlesreid1 ) that can be used to link a Gitea (or Github) repository to Captain Hook. Gitea (and Github) send payloads with webhooks that specify information like the action that triggered the webhook, and the repository/branch on which the action was performed. Captain Hook runs inside of a docker container. The docker container mounts the pages.charlesreid1.com web directory inside the container. Generally the hook scripts will deploy the gh-apges branch to this web directory.","title":"What is Captain Hook?"},{"location":"what/#what-is-captain-hook","text":"","title":"What is Captain Hook?"},{"location":"what/#the-short-version","text":"Captain Hook enables a Github Pages-like push-to-deploy setup for git.charlesreid1.com. Installing webhooks into repositories on https://git.charlesreid1.com allows the gh-pages branch of the given repository to be hosted live on https://pages.charlesreid1.com .","title":"The Short Version"},{"location":"what/#the-long-version","text":"Captain Hook is a Python Flask server that listens for incoming web hooks from Gitea (or Github), and uses those web hooks to deply pages to https://pages.charlesreid1.com . Captain Hook works by providing a webhook endpoint (rounting provided by nginx container in pod-charlesreid1 ) that can be used to link a Gitea (or Github) repository to Captain Hook. Gitea (and Github) send payloads with webhooks that specify information like the action that triggered the webhook, and the repository/branch on which the action was performed. Captain Hook runs inside of a docker container. The docker container mounts the pages.charlesreid1.com web directory inside the container. Generally the hook scripts will deploy the gh-apges branch to this web directory.","title":"The Long Version"}]}